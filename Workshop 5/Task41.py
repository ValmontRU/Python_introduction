# Реализуйте RLE алгоритм: реализуйте модуль сжатия и восстановления данных.

# Метод кодировки.
def coding(txt):
    count = 1 # По умолчанию счётчик равен 1.
    res = '' # Создаётся переменная в виде пустой строки.
    for i in range(len(txt)-1): # Проходится каждый элемент входящего текста.
        if txt[i] == txt[i+1]: # Если 2 соседних элемента равны...
            count += 1 # ... счётчик увеличивается.
        else:
            res = res + str(count) + txt[i] # Строковая переменная дополняется числом счётчика и значением повторяющегося элемента.
            count = 1 # После этого счётчик сбрасывается для проверки следующих элементов.
    if count > 1 or (txt[len(txt)-2] != txt[-1]): # Если в конце цикла счётчик не сброшен или 2 последних элемента не равны, то...
        res = res + str(count) + txt[-1] # ... строковая переменная дополняется числом счётчика и значением последнего элемента.
    return res # Возвращается накопленная строковая переменная - закодированный текст.

# Метод декодировки.
def decoding(txt):
    number = ''
    res = ''
    for i in range(len(txt)):
        if not txt[i].isalpha(): # Если элемент не является буквой...
            number += txt[i] # ... числовая переменная приобретает соответствующее элементу значение числа.
        else:
            res = res + txt[i] * int(number) # Строковая переменная дополняется значением текстового элемента в количестве, равном
            number = '' # Переменная "опустошается" для проверки следующих элементов.
    return res # Возвращается накопленная строковая переменная - декодированный текст.

with open('infile.txt', 'r') as data:
    incoming = data.read()

code = coding(incoming)
with open('codefile.txt', 'w') as data1:
    data1.write(code)

decode = decoding(code)
with open('decodefile.txt', 'w') as data2:
    data2.write(decode)
